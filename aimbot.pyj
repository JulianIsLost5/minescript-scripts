import system.pyj.minescript as m

Double = JavaClass("java.lang.Double")
Minecraft = JavaClass("net.minecraft.client.Minecraft")
Math = JavaClass("java.lang.Math")
BowItem = JavaClass("net.minecraft.world.item.BowItem")

mc = Minecraft.getInstance()

def lock_on(target): # target is subclass of entity
    def _bow_speed(player):
        bow = player.getUseItem()
        
        use_ticks = BowItem.getUseDuration(bow, player) - player.getUseItemRemainingTicks()
        pull = BowItem.getPowerForTime(use_ticks)
        speed = pull * 3.0
        return speed
        
    def _simulate_interception(player, target, steps):
        best_error = float("inf")
        best_vec = None
        
        arrow_speed = _bow_speed(player)
        
        arrow_direction = player.getViewVector(1).normalize()
        arrow_velocity = arrow_direction.scale(arrow_speed)
        
        target_velocity = target.getDeltaMovement()
        
        arrow_pos = player.getEyePosition()
        target_pos = target.getEyePosition()
        
        for i in range(steps):
            arrow_pos = arrow_pos.add(arrow_velocity)
            arrow_velocity = arrow_velocity.scale(0.99)
            arrow_velocity = arrow_velocity.subtract(0, 0.05, 0)
            
            target_pos = target_pos.add(target_velocity)
            
            error = target_pos.distanceTo(arrow_pos)
            if error < best_error:
                best_error = error
                correction = target_pos.subtract(arrow_pos).normalize().scale(0.05)
                best_vec = arrow_direction.add(correction).normalize()
        
        yaw = Math.toDegrees(Math.atan2(-best_vec.x, best_vec.z))
        pitch = Math.toDegrees(-Math.asin(best_vec.y))
        
        m.player_set_orientation(yaw, pitch)
        
    for i in range(10):
        _simulate_interception(mc.player, target, 200)
