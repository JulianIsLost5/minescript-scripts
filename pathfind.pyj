import reflection_utils as ru

Zombie = JavaClass("net.minecraft.world.entity.monster.Zombie")
EntityType = JavaClass("net.minecraft.world.entity.EntityType")
Vec3 = JavaClass("net.minecraft.world.phys.Vec3")
ClientTickEvents = JavaClass("net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents")

class AutoWalk:
    def __init__(self):
        self.path = None
        self.current_node_index = 0
        self.target = None


        ClientTickEvents.END_CLIENT_TICK.register(ClientTickEvents(self.client_tick))
        
    def client_tick(self, client):
        if client.player is None or client.level is None:
            return

        self.follow_path(client.player)

    def set_target(client, target_pos): # target_pos: Vec3d
        self.target = target_pos
        self.current_node_index = 0

        # Use a dummy zombie for pathfinding
        dummy = Zombie(EntityType.ZOMBIE, client.level)
        nav = dummy.getNavigation()
        self.path = nav.createPath(target_pos, 0)

    def follow_path(player),
        if self.path is None or self.current_node_index >= self.path.getNodeCount():
            return

        # Get current target node
        target_pos = self.path.getNodePos(current_node_index)

        # If close enough, go to next node
        if (player.position().distanceToSqr(target_pos) < 0.3):
            self.current_node_index += 1
            return

        # Compute direction toward next node
        direction = target_pos.subtract(player.position()).normalize()

        speed = 0.1 # walking speed per tick
        step = Vec3(direction.x * speed, direction.y * speed, direction.z * speed)

        # Handle small jumps (stairs)
        if target_pos.y > player.getY() + 0.5):
            player.jumpFromGround()

        # Apply movement
        player.absSnapTo(player.getX() + step.x, player.getY() + step.y, player.getZ() + step.z)

        # Sync with server
        ru.call_private_method(player, "method_3136")
